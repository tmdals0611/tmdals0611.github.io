---
title: "[ì»´íŒŒì¼ëŸ¬] 2. ì–´íœ˜ ë¶„ì„ (Lexical Analysis)"
date: 2025-02-07 14:30:00 +0900
categories: [Computer Science, Compiler Design]
tags: [lexical-analysis, tokenization, regex, finite-automata, lex, flex, compiler-frontend, theory]
pin: false
math: true
mermaid: true
---

ì»´íŒŒì¼ëŸ¬ì˜ ì²« ë‹¨ê³„ì¸ **ì–´íœ˜ ë¶„ì„(Lexical Analysis)**ì€ ì†ŒìŠ¤ ì½”ë“œë¥¼ ì½ì–´ ì˜ë¯¸ ìˆëŠ” ë‹¨ìœ„ì¸ í† í°(Token)ìœ¼ë¡œ ë¶„ë¦¬í•˜ëŠ” ì‘ì—…ì…ë‹ˆë‹¤. ì´ ê³¼ì •ì€ ì»´íŒŒì¼ëŸ¬ì˜ ê¸°ì´ˆì´ì í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ì²˜ë¦¬ì˜ ì¶œë°œì ì…ë‹ˆë‹¤.

## ğŸ“š ì»´íŒŒì¼ëŸ¬ êµ¬ì¡° ê°œìš”

### ì»´íŒŒì¼ ê³¼ì •

```mermaid
graph LR
    A[ì†ŒìŠ¤ ì½”ë“œ] -->|ì–´íœ˜ ë¶„ì„| B[í† í° ìŠ¤íŠ¸ë¦¼]
    B -->|êµ¬ë¬¸ ë¶„ì„| C[íŒŒìŠ¤ íŠ¸ë¦¬]
    C -->|ì˜ë¯¸ ë¶„ì„| D[ì£¼ì„ íŒŒìŠ¤ íŠ¸ë¦¬]
    D -->|ì¤‘ê°„ ì½”ë“œ ìƒì„±| E[ì¤‘ê°„ í‘œí˜„]
    E -->|ìµœì í™”| F[ìµœì í™”ëœ IR]
    F -->|ì½”ë“œ ìƒì„±| G[íƒ€ê²Ÿ ì½”ë“œ]
```

### ì»´íŒŒì¼ëŸ¬ ë‹¨ê³„ë³„ ì—­í• 

| ë‹¨ê³„ | ì…ë ¥ | ì¶œë ¥ | ì—­í•  |
|------|------|------|------|
| **ì–´íœ˜ ë¶„ì„** | ë¬¸ì ìŠ¤íŠ¸ë¦¼ | í† í° ìŠ¤íŠ¸ë¦¼ | í† í° ì¸ì‹ |
| **êµ¬ë¬¸ ë¶„ì„** | í† í° ìŠ¤íŠ¸ë¦¼ | íŒŒìŠ¤ íŠ¸ë¦¬ | ë¬¸ë²• ê²€ì¦ |
| **ì˜ë¯¸ ë¶„ì„** | íŒŒìŠ¤ íŠ¸ë¦¬ | ì£¼ì„ íŠ¸ë¦¬ | íƒ€ì… ê²€ì‚¬ |
| **ì¤‘ê°„ ì½”ë“œ ìƒì„±** | ì£¼ì„ íŠ¸ë¦¬ | IR | ì¤‘ê°„ í‘œí˜„ |
| **ìµœì í™”** | IR | ìµœì í™”ëœ IR | ì„±ëŠ¥ í–¥ìƒ |
| **ì½”ë“œ ìƒì„±** | IR | íƒ€ê²Ÿ ì½”ë“œ | ê¸°ê³„ì–´ ìƒì„± |

### í”„ë¡ íŠ¸ì—”ë“œ vs ë°±ì—”ë“œ

**í”„ë¡ íŠ¸ì—”ë“œ** (ì†ŒìŠ¤ ì–¸ì–´ ì˜ì¡´):
- ì–´íœ˜ ë¶„ì„
- êµ¬ë¬¸ ë¶„ì„
- ì˜ë¯¸ ë¶„ì„
- ì¤‘ê°„ ì½”ë“œ ìƒì„±

**ë°±ì—”ë“œ** (íƒ€ê²Ÿ ê¸°ê³„ ì˜ì¡´):
- ì½”ë“œ ìµœì í™”
- ì½”ë“œ ìƒì„±
- ë ˆì§€ìŠ¤í„° í• ë‹¹

---

## ì–´íœ˜ ë¶„ì„(Lexical Analysis)ì´ë€?

### ì •ì˜

**ì–´íœ˜ ë¶„ì„ê¸°(Lexical Analyzer, Scanner, Lexer)**:
- ì†ŒìŠ¤ ì½”ë“œë¥¼ ì½ì–´ í† í°(Token) ì‹œí€€ìŠ¤ë¡œ ë³€í™˜
- ê³µë°±, ì£¼ì„ ì œê±°
- ì—ëŸ¬ ì²˜ë¦¬ (ì˜ëª»ëœ ë¬¸ì, ëë‚˜ì§€ ì•Šì€ ë¬¸ìì—´ ë“±)

### ì…ë ¥ê³¼ ì¶œë ¥

**ì…ë ¥**: ë¬¸ì ìŠ¤íŠ¸ë¦¼
```c
int main() {
    int x = 10 + 20;
    return x;
}
```

**ì¶œë ¥**: í† í° ìŠ¤íŠ¸ë¦¼
```
<KEYWORD, int>
<ID, main>
<LPAREN, (>
<RPAREN, )>
<LBRACE, {>
<KEYWORD, int>
<ID, x>
<ASSIGN, =>
<NUMBER, 10>
<PLUS, +>
<NUMBER, 20>
<SEMICOLON, ;>
<KEYWORD, return>
<ID, x>
<SEMICOLON, ;>
<RBRACE, }>
```

### ì™œ ë¶„ë¦¬í•˜ëŠ”ê°€?

**1. ë‹¨ìˆœí™”**:
- êµ¬ë¬¸ ë¶„ì„ê¸°ëŠ” ë¬¸ìê°€ ì•„ë‹Œ í† í°ë§Œ ì²˜ë¦¬
- ê³µë°±/ì£¼ì„ ì²˜ë¦¬ ë¶„ë¦¬

**2. íš¨ìœ¨ì„±**:
- íŠ¹í™”ëœ ê¸°ë²• ì‚¬ìš© ê°€ëŠ¥
- ë²„í¼ë§ ìµœì í™”

**3. ì´ì‹ì„±**:
- ì…ë ¥ ì¥ì¹˜ ë…ë¦½ì 
- ë¬¸ì ì¸ì½”ë”© ì¶”ìƒí™”

---

## í† í°(Token)ê³¼ ë ‰ì‹¬(Lexeme)

### ìš©ì–´ ì •ì˜

**í† í°(Token)**:
- ì˜ë¯¸ ìˆëŠ” ë¬¸ìì—´ì˜ ë²”ì£¼
- ì˜ˆ: KEYWORD, IDENTIFIER, NUMBER, OPERATOR

**ë ‰ì‹¬(Lexeme)**:
- í† í°ì— í•´ë‹¹í•˜ëŠ” ì‹¤ì œ ë¬¸ìì—´
- ì˜ˆ: "int", "main", "123", "+"

**íŒ¨í„´(Pattern)**:
- í† í°ì„ ì¸ì‹í•˜ëŠ” ê·œì¹™
- ì •ê·œ í‘œí˜„ì‹ìœ¼ë¡œ í‘œí˜„

**ì˜ˆì‹œ**:
```c
int count = 42;
```

| ë ‰ì‹¬ | í† í° | íŒ¨í„´ |
|------|------|------|
| `int` | KEYWORD | `int|float|char|...` |
| `count` | IDENTIFIER | `[a-zA-Z_][a-zA-Z0-9_]*` |
| `=` | ASSIGN | `=` |
| `42` | NUMBER | `[0-9]+` |
| `;` | SEMICOLON | `;` |

### í† í°ì˜ ì¢…ë¥˜

**1. í‚¤ì›Œë“œ(Keywords)**:
```
if, else, while, for, int, float, return, ...
```

**2. ì‹ë³„ì(Identifiers)**:
```
ë³€ìˆ˜ëª…, í•¨ìˆ˜ëª…: x, count, calculateSum, ...
```

**3. ë¦¬í„°ëŸ´(Literals)**:
```
ì •ìˆ˜: 123, 0xFF, 0b1010
ì‹¤ìˆ˜: 3.14, 1.5e-3
ë¬¸ì: 'a', '\n'
ë¬¸ìì—´: "Hello, World!"
```

**4. ì—°ì‚°ì(Operators)**:
```
ì‚°ìˆ : +, -, *, /, %
ê´€ê³„: <, >, <=, >=, ==, !=
ë…¼ë¦¬: &&, ||, !
ë¹„íŠ¸: &, |, ^, ~, <<, >>
í• ë‹¹: =, +=, -=, *=, ...
```

**5. êµ¬ë¶„ì(Delimiters)**:
```
( ) { } [ ] ; , . : -> ...
```

**6. ì£¼ì„(Comments)**:
```c
// í•œ ì¤„ ì£¼ì„
/* ì—¬ëŸ¬ ì¤„
   ì£¼ì„ */
```

---

## ì •ê·œ í‘œí˜„ì‹ (Regular Expression)

### ì •ê·œ í‘œí˜„ì‹ì´ë€?

**ì •ì˜**: ë¬¸ìì—´ íŒ¨í„´ì„ í‘œí˜„í•˜ëŠ” í˜•ì‹ ì–¸ì–´

**ìš©ë„**:
- í† í° íŒ¨í„´ ì •ì˜
- ë¬¸ìì—´ ë§¤ì¹­
- ìœ í•œ ì˜¤í† ë§ˆíƒ€ë¡œ ë³€í™˜ ê°€ëŠ¥

### ê¸°ë³¸ ì—°ì‚°ì

**1. ë¬¸ì(Character)**:
```
a     : ë¬¸ì 'a'
abc   : ë¬¸ìì—´ "abc"
```

**2. ì„ íƒ(Alternation) - `|`**:
```
a|b   : 'a' ë˜ëŠ” 'b'
cat|dog : "cat" ë˜ëŠ” "dog"
```

**3. ì—°ì ‘(Concatenation)**:
```
ab    : 'a' ë‹¤ìŒì— 'b'
abc   : 'a' ë‹¤ìŒì— 'b' ë‹¤ìŒì— 'c'
```

**4. ë°˜ë³µ(Repetition) - `*`**:
```
a*    : 'a'ê°€ 0ë²ˆ ì´ìƒ (Îµ, a, aa, aaa, ...)
(ab)* : "ab"ê°€ 0ë²ˆ ì´ìƒ (Îµ, ab, abab, ...)
```

**5. í•˜ë‚˜ ì´ìƒ - `+`**:
```
a+    : 'a'ê°€ 1ë²ˆ ì´ìƒ (a, aa, aaa, ...)
[0-9]+ : ìˆ«ìê°€ 1ê°œ ì´ìƒ
```

**6. ì˜µì…˜ - `?`**:
```
a?    : 'a'ê°€ 0ë²ˆ ë˜ëŠ” 1ë²ˆ (Îµ, a)
-?[0-9]+ : ì„ íƒì  ë¶€í˜¸ê°€ ìˆëŠ” ì •ìˆ˜
```

**7. ë¬¸ì í´ë˜ìŠ¤ - `[ ]`**:
```
[abc]    : a, b, c ì¤‘ í•˜ë‚˜
[a-z]    : ì†Œë¬¸ì ì•ŒíŒŒë²³
[0-9]    : ìˆ«ì
[^0-9]   : ìˆ«ìê°€ ì•„ë‹Œ ê²ƒ
```

**8. ì•µì»¤**:
```
^abc  : ì¤„ ì‹œì‘ì—ì„œ abc
abc$  : ì¤„ ëì—ì„œ abc
```

### ì •ê·œ í‘œí˜„ì‹ ì˜ˆì‹œ

**ì‹ë³„ì**:
```regex
[a-zA-Z_][a-zA-Z0-9_]*

ì„¤ëª…:
- ì²« ë¬¸ì: ì•ŒíŒŒë²³ ë˜ëŠ” ë°‘ì¤„
- ì´í›„ ë¬¸ì: ì•ŒíŒŒë²³, ìˆ«ì, ë°‘ì¤„ (0ê°œ ì´ìƒ)

ë§¤ì¹­: x, count, _temp, my_var123
ë¶ˆë§¤ì¹­: 1abc, -name
```

**ì •ìˆ˜**:
```regex
-?[0-9]+

ì„¤ëª…:
- ì„ íƒì  ë¶€í˜¸ -
- ìˆ«ì 1ê°œ ì´ìƒ

ë§¤ì¹­: 123, -456, 0
ë¶ˆë§¤ì¹­: 1.5, abc
```

**ë¶€ë™ì†Œìˆ˜ì **:
```regex
-?[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?

ì„¤ëª…:
- ì„ íƒì  ë¶€í˜¸
- ì •ìˆ˜ ë¶€ë¶„
- ì„ íƒì  ì†Œìˆ˜ì ê³¼ ì†Œìˆ˜ ë¶€ë¶„
- ì„ íƒì  ì§€ìˆ˜ í‘œê¸°

ë§¤ì¹­: 3.14, -0.5, 1.5e-3, 2E+10
ë¶ˆë§¤ì¹­: .5, 1., e10
```

**C í‚¤ì›Œë“œ**:
```regex
if|else|while|for|int|float|return|...

ë§¤ì¹­: if, while, return
ë¶ˆë§¤ì¹­: iff, whilee
```

**ì£¼ì„**:
```regex
//.*$           # í•œ ì¤„ ì£¼ì„
/\*([^*]|\*+[^*/])*\*+/  # ì—¬ëŸ¬ ì¤„ ì£¼ì„
```

### ì •ê·œ í‘œí˜„ì‹ ìš°ì„ ìˆœìœ„

**ë†’ìŒ â†’ ë‚®ìŒ**:
1. `*`, `+`, `?` (ë°˜ë³µ)
2. ì—°ì ‘
3. `|` (ì„ íƒ)

**ì˜ˆì‹œ**:
```
ab|cd   = (ab)|(cd)   âœ…
ab*     = a(b*)       âœ…
a|b*    = a|(b*)      âœ…
(a|b)*  = (a ë˜ëŠ” b)ê°€ 0ë²ˆ ì´ìƒ
```

---

## ìœ í•œ ì˜¤í† ë§ˆíƒ€ (Finite Automata)

### ì •ì˜

**ìœ í•œ ì˜¤í† ë§ˆíƒ€(FA, Finite Automaton)**:
- ìƒíƒœì˜ ìœ í•œ ì§‘í•©
- ì…ë ¥ì— ë”°ë¼ ìƒíƒœ ì „ì´
- ë¬¸ìì—´ ì¸ì‹ ê¸°ê³„

**ìš©ë„**:
- ì •ê·œ í‘œí˜„ì‹ êµ¬í˜„
- í† í° ì¸ì‹
- íš¨ìœ¨ì ì¸ íŒ¨í„´ ë§¤ì¹­

### NFA (Nondeterministic FA)

**ì •ì˜**: í•˜ë‚˜ì˜ ì…ë ¥ì— ëŒ€í•´ ì—¬ëŸ¬ ìƒíƒœë¡œ ì „ì´ ê°€ëŠ¥

**íŠ¹ì§•**:
- Îµ-ì „ì´ í—ˆìš© (ì…ë ¥ ì—†ì´ ì „ì´)
- ì„ íƒì  ê²½ë¡œ ì¡´ì¬
- êµ¬í˜„ì´ ë‹¨ìˆœ

**ì˜ˆì‹œ**: ì •ê·œ í‘œí˜„ì‹ `ab|ac`

```mermaid
stateDiagram-v2
    [*] --> s0
    s0 --> s1: a
    s1 --> s2: b
    s1 --> s3: c
    s2 --> [*]
    s3 --> [*]
```

**ì „ì´ í‘œ**:
| ìƒíƒœ | a | b | c |
|------|---|---|---|
| s0 | {s1} | âˆ… | âˆ… |
| s1 | âˆ… | {s2} | {s3} |
| s2 | âˆ… | âˆ… | âˆ… |
| s3 | âˆ… | âˆ… | âˆ… |

### DFA (Deterministic FA)

**ì •ì˜**: ê° ìƒíƒœì—ì„œ ê° ì…ë ¥ì— ëŒ€í•´ ì •í™•íˆ í•˜ë‚˜ì˜ ë‹¤ìŒ ìƒíƒœ

**íŠ¹ì§•**:
- Îµ-ì „ì´ ì—†ìŒ
- ê²°ì •ì  (deterministic)
- êµ¬í˜„ì´ íš¨ìœ¨ì 

**ì˜ˆì‹œ**: ìœ„ NFAì™€ ë™ì¼í•œ ì–¸ì–´

```mermaid
stateDiagram-v2
    [*] --> s0
    s0 --> s1: a
    s1 --> s2: b
    s1 --> s3: c
    s2 --> [*]
    s3 --> [*]
```

**ì „ì´ í‘œ**:
| ìƒíƒœ | a | b | c |
|------|---|---|---|
| s0 | s1 | âˆ… | âˆ… |
| s1 | âˆ… | s2 | s3 |
| s2 | âˆ… | âˆ… | âˆ… |
| s3 | âˆ… | âˆ… | âˆ… |

### NFA â†’ DFA ë³€í™˜ (ë¶€ë¶„ì§‘í•© êµ¬ì„±)

**ëª©ì **: NFAë¥¼ íš¨ìœ¨ì ì¸ DFAë¡œ ë³€í™˜

**ë°©ë²•**: NFAì˜ ìƒíƒœ ì§‘í•©ì„ DFAì˜ ìƒíƒœë¡œ

**ì˜ˆì‹œ**: ì •ê·œ í‘œí˜„ì‹ `a*b`

**NFA**:
```mermaid
stateDiagram-v2
    [*] --> q0
    q0 --> q0: a
    q0 --> q1: b
    q1 --> [*]
```

**DFA** (ë™ì¼):
```mermaid
stateDiagram-v2
    [*] --> q0
    q0 --> q0: a
    q0 --> q1: b
    q1 --> [*]
```

**ë³µì¡í•œ ì˜ˆì‹œ**: `(a|b)*abb`

**ê³¼ì •**:
1. Îµ-closure ê³„ì‚°
2. ì „ì´ í•¨ìˆ˜ ê³„ì‚°
3. ìƒˆë¡œìš´ ìƒíƒœ ìƒì„±

---

## ì‹¤ì œ ì˜ˆì‹œ: ì‹ë³„ìì™€ í‚¤ì›Œë“œ ì¸ì‹

### ì •ê·œ í‘œí˜„ì‹

**ì‹ë³„ì**:
```
[a-zA-Z_][a-zA-Z0-9_]*
```

**í‚¤ì›Œë“œ**:
```
if | else | while | for | ...
```

### DFA ì„¤ê³„

**ì‹ë³„ì/í‚¤ì›Œë“œ ì¸ì‹ DFA**:

```mermaid
stateDiagram-v2
    [*] --> Start
    Start --> ID: [a-zA-Z_]
    ID --> ID: [a-zA-Z0-9_]
    ID --> [*]: other
```

**ì²˜ë¦¬ ê³¼ì •**:
```c
// ì…ë ¥: "if"
1. 'i' â†’ ID ìƒíƒœ
2. 'f' â†’ ID ìƒíƒœ ìœ ì§€
3. ê³µë°± â†’ ì¢…ë£Œ
4. í‚¤ì›Œë“œ í…Œì´ë¸” í™•ì¸ â†’ "if"ëŠ” í‚¤ì›Œë“œ
5. í† í°: <KEYWORD, if>

// ì…ë ¥: "count"
1. 'c' â†’ ID ìƒíƒœ
2. 'o' â†’ ID ìƒíƒœ
3. 'u' â†’ ID ìƒíƒœ
4. 'n' â†’ ID ìƒíƒœ
5. 't' â†’ ID ìƒíƒœ
6. ê³µë°± â†’ ì¢…ë£Œ
7. í‚¤ì›Œë“œ í…Œì´ë¸” í™•ì¸ â†’ ì—†ìŒ
8. í† í°: <ID, count>
```

### ìˆ«ì ì¸ì‹

**ì •ê·œ í‘œí˜„ì‹**:
```
ì •ìˆ˜: [0-9]+
ì‹¤ìˆ˜: [0-9]+\.[0-9]+
```

**DFA**:

```mermaid
stateDiagram-v2
    [*] --> Start
    Start --> INT: [0-9]
    INT --> INT: [0-9]
    INT --> DOT: .
    DOT --> FLOAT: [0-9]
    FLOAT --> FLOAT: [0-9]
    INT --> [*]: other
    FLOAT --> [*]: other
```

**ì²˜ë¦¬ ì˜ˆì‹œ**:
```
ì…ë ¥: "123"    â†’ <NUMBER, 123>
ì…ë ¥: "3.14"   â†’ <NUMBER, 3.14>
ì…ë ¥: "12.34"  â†’ <NUMBER, 12.34>
```

---

## Lex/Flexë¥¼ ì´ìš©í•œ ì–´íœ˜ ë¶„ì„ê¸° êµ¬í˜„

### Lex/Flexë€?

**Lex (Lexical Analyzer Generator)**:
- ì •ê·œ í‘œí˜„ì‹ì„ DFAë¡œ ìë™ ë³€í™˜
- C ì½”ë“œ ìƒì„±
- FlexëŠ” Lexì˜ ê°œì„  ë²„ì „

### Lex í”„ë¡œê·¸ë¨ êµ¬ì¡°

```lex
%{
/* C ì„ ì–¸ë¶€ */
#include <stdio.h>
int line_num = 1;
%}

/* ì •ê·œ í‘œí˜„ì‹ ì •ì˜ */
%%

/* íŒ¨í„´-ë™ì‘ ê·œì¹™ */
"if"        { return IF; }
"else"      { return ELSE; }
"while"     { return WHILE; }
[a-zA-Z_][a-zA-Z0-9_]*  { return ID; }
[0-9]+      { return NUMBER; }
[ \t]+      { /* ê³µë°± ë¬´ì‹œ */ }
\n          { line_num++; }
.           { printf("Unknown character: %s\n", yytext); }

%%

/* C í•¨ìˆ˜ ì •ì˜ */
int yywrap() {
    return 1;
}
```

### ê°„ë‹¨í•œ ì˜ˆì œ

**simple.l**:
```lex
%{
#include <stdio.h>
%}

%%

"if"        { printf("KEYWORD: if\n"); }
"else"      { printf("KEYWORD: else\n"); }
"while"     { printf("KEYWORD: while\n"); }
[a-zA-Z_][a-zA-Z0-9_]*  { printf("ID: %s\n", yytext); }
[0-9]+      { printf("NUMBER: %s\n", yytext); }
"+"         { printf("PLUS\n"); }
"-"         { printf("MINUS\n"); }
"*"         { printf("MULT\n"); }
"/"         { printf("DIV\n"); }
"="         { printf("ASSIGN\n"); }
"("         { printf("LPAREN\n"); }
")"         { printf("RPAREN\n"); }
"{"         { printf("LBRACE\n"); }
"}"         { printf("RBRACE\n"); }
";"         { printf("SEMICOLON\n"); }
[ \t\n]+    { /* ê³µë°± ë¬´ì‹œ */ }
.           { printf("Unknown: %s\n", yytext); }

%%

int main() {
    yylex();
    return 0;
}

int yywrap() {
    return 1;
}
```

**ì»´íŒŒì¼ ë° ì‹¤í–‰**:
```bash
flex simple.l
gcc lex.yy.c -lfl -o lexer
echo "int x = 10 + 20;" | ./lexer
```

**ì¶œë ¥**:
```
KEYWORD: int
ID: x
ASSIGN
NUMBER: 10
PLUS
NUMBER: 20
SEMICOLON
```

### ì¢€ ë” ë³µì¡í•œ ì˜ˆì œ: C ì–¸ì–´ ë¶€ë¶„ì§‘í•©

**c_lexer.l**:
```lex
%{
#include <stdio.h>
#include <string.h>
%}

DIGIT       [0-9]
LETTER      [a-zA-Z_]
ID          {LETTER}({LETTER}|{DIGIT})*
NUMBER      {DIGIT}+
FLOAT       {DIGIT}+\.{DIGIT}+

%%

"int"       { printf("<KEYWORD, int>\n"); }
"float"     { printf("<KEYWORD, float>\n"); }
"char"      { printf("<KEYWORD, char>\n"); }
"if"        { printf("<KEYWORD, if>\n"); }
"else"      { printf("<KEYWORD, else>\n"); }
"while"     { printf("<KEYWORD, while>\n"); }
"for"       { printf("<KEYWORD, for>\n"); }
"return"    { printf("<KEYWORD, return>\n"); }

{ID}        { printf("<ID, %s>\n", yytext); }
{NUMBER}    { printf("<NUMBER, %s>\n", yytext); }
{FLOAT}     { printf("<FLOAT, %s>\n", yytext); }

"+"         { printf("<OP, +>\n"); }
"-"         { printf("<OP, ->\n"); }
"*"         { printf("<OP, *>\n"); }
"/"         { printf("<OP, />\n"); }
"="         { printf("<ASSIGN, =>\n"); }
"=="        { printf("<EQ, ==>\n"); }
"!="        { printf("<NEQ, !=>\n"); }
"<"         { printf("<LT, <>\n"); }
">"         { printf("<GT, >>\n"); }
"<="        { printf("<LE, <=>\n"); }
">="        { printf("<GE, >=>\n"); }

"("         { printf("<LPAREN, (>\n"); }
")"         { printf("<RPAREN, )>\n"); }
"{"         { printf("<LBRACE, {>\n"); }
"}"         { printf("<RBRACE, }>\n"); }
";"         { printf("<SEMICOLON, ;>\n"); }
","         { printf("<COMMA, ,>\n"); }

"//".*      { /* í•œ ì¤„ ì£¼ì„ ë¬´ì‹œ */ }
"/*"([^*]|\*+[^*/])*\*+"/"  { /* ì—¬ëŸ¬ ì¤„ ì£¼ì„ ë¬´ì‹œ */ }

[ \t\n]+    { /* ê³µë°± ë¬´ì‹œ */ }

.           { printf("Unknown character: %s\n", yytext); }

%%

int main(int argc, char **argv) {
    if (argc > 1) {
        FILE *f = fopen(argv[1], "r");
        if (f) {
            yyin = f;
            yylex();
            fclose(f);
        }
    } else {
        yylex();
    }
    return 0;
}

int yywrap() {
    return 1;
}
```

**í…ŒìŠ¤íŠ¸ ì…ë ¥** (`test.c`):
```c
int main() {
    int x = 10;
    int y = 20;
    return x + y;
}
```

**ì‹¤í–‰**:
```bash
flex c_lexer.l
gcc lex.yy.c -lfl -o c_lexer
./c_lexer test.c
```

**ì¶œë ¥**:
```
<KEYWORD, int>
<ID, main>
<LPAREN, (>
<RPAREN, )>
<LBRACE, {>
<KEYWORD, int>
<ID, x>
<ASSIGN, =>
<NUMBER, 10>
<SEMICOLON, ;>
<KEYWORD, int>
<ID, y>
<ASSIGN, =>
<NUMBER, 20>
<SEMICOLON, ;>
<KEYWORD, return>
<ID, x>
<OP, +>
<ID, y>
<SEMICOLON, ;>
<RBRACE, }>
```

---

## ì–´íœ˜ ë¶„ì„ê¸° ì„¤ê³„ ê³ ë ¤ì‚¬í•­

### 1. í‚¤ì›Œë“œ vs ì‹ë³„ì

**ë¬¸ì œ**: í‚¤ì›Œë“œì™€ ì‹ë³„ìëŠ” ê°™ì€ íŒ¨í„´

**í•´ê²° ë°©ë²•**:

**ë°©ë²• 1: ìš°ì„ ìˆœìœ„**
```lex
"if"        { return IF; }
"while"     { return WHILE; }
[a-zA-Z_]+ { return ID; }
```
- LexëŠ” ë¨¼ì € ë§¤ì¹­ë˜ëŠ” ê·œì¹™ ì„ íƒ
- í‚¤ì›Œë“œë¥¼ ì‹ë³„ìë³´ë‹¤ ë¨¼ì € ì •ì˜

**ë°©ë²• 2: ì˜ˆì•½ì–´ í…Œì´ë¸”**
```c
int check_keyword(char *str) {
    if (strcmp(str, "if") == 0) return IF;
    if (strcmp(str, "while") == 0) return WHILE;
    // ...
    return ID;
}
```

### 2. ìµœì¥ ë§¤ì¹­ (Longest Match)

**ì›ì¹™**: ê°€ëŠ¥í•œ ê°€ì¥ ê¸´ ë ‰ì‹¬ ì„ íƒ

**ì˜ˆì‹œ**:
```c
int count = 123;
```

- `count`ë¥¼ `c`, `co`, `cou`, `coun`, `count` ì¤‘ ì„ íƒ?
- â†’ `count` (ìµœì¥)

- `123`ì„ `1`, `12`, `123` ì¤‘ ì„ íƒ?
- â†’ `123` (ìµœì¥)

### 3. ì„ í–‰ ë§¤ì¹­ (First Match)

**ì›ì¹™**: ì—¬ëŸ¬ íŒ¨í„´ì´ ë§¤ì¹­ë˜ë©´ ë¨¼ì € ì •ì˜ëœ ê²ƒ ì„ íƒ

**ì˜ˆì‹œ**:
```lex
"<="    { return LE; }
"<"     { return LT; }
```

- ì…ë ¥ `<=`: ì²« ë²ˆì§¸ ê·œì¹™ ë§¤ì¹­
- ì…ë ¥ `<`: ë‘ ë²ˆì§¸ ê·œì¹™ ë§¤ì¹­

### 4. ì—ëŸ¬ ì²˜ë¦¬

**ì „ëµ**:

**ë¬´ì‹œ (Ignore)**:
```lex
.   { /* ë¬´ì‹œ */ }
```

**ì—ëŸ¬ ë©”ì‹œì§€**:
```lex
.   { fprintf(stderr, "Illegal character: %c\n", yytext[0]); }
```

**ë³µêµ¬ (Recovery)**:
```lex
.   {
    fprintf(stderr, "Error at line %d\n", line_num);
    /* ë‹¤ìŒ í† í°ê¹Œì§€ ê±´ë„ˆë›°ê¸° */
}
```

### 5. ì¤„ ë²ˆí˜¸ ì¶”ì 

```lex
%{
int line_num = 1;
%}

%%

\n      { line_num++; }
[a-zA-Z_]+ { printf("Line %d: ID %s\n", line_num, yytext); }

%%
```

### 6. ë¬¸ìì—´ê³¼ ì£¼ì„ ì²˜ë¦¬

**ë¬¸ìì—´**:
```lex
\"([^"\\]|\\.)*\"  { return STRING; }
```

**ì£¼ì„**:
```lex
"//".*             { /* í•œ ì¤„ ì£¼ì„ */ }
"/*"([^*]|\*+[^*/])*\*+"/"  { /* ì—¬ëŸ¬ ì¤„ ì£¼ì„ */ }
```

---

## ì‹¤ìŠµ: ê°„ë‹¨í•œ ê³„ì‚°ê¸° ì–´íœ˜ ë¶„ì„ê¸°

### ëª©í‘œ

ìˆ˜ì‹ì„ ì…ë ¥ë°›ì•„ í† í°ìœ¼ë¡œ ë¶„í•´

**ì…ë ¥ ì˜ˆì‹œ**:
```
3 + 5 * (10 - 2)
```

**ì¶œë ¥**:
```
<NUMBER, 3>
<PLUS, +>
<NUMBER, 5>
<MULT, *>
<LPAREN, (>
<NUMBER, 10>
<MINUS, ->
<NUMBER, 2>
<RPAREN, )>
```

### Lex ì½”ë“œ

**calc_lexer.l**:
```lex
%{
#include <stdio.h>
%}

%%

[0-9]+      { printf("<NUMBER, %s>\n", yytext); }
"+"         { printf("<PLUS, +>\n"); }
"-"         { printf("<MINUS, ->\n"); }
"*"         { printf("<MULT, *>\n"); }
"/"         { printf("<DIV, />\n"); }
"("         { printf("<LPAREN, (>\n"); }
")"         { printf("<RPAREN, )>\n"); }
[ \t\n]+    { /* ê³µë°± ë¬´ì‹œ */ }
.           { printf("Unknown: %s\n", yytext); }

%%

int main() {
    printf("Enter expression:\n");
    yylex();
    return 0;
}

int yywrap() {
    return 1;
}
```

**ì»´íŒŒì¼ ë° ì‹¤í–‰**:
```bash
flex calc_lexer.l
gcc lex.yy.c -lfl -o calc_lexer
./calc_lexer
```

---

## ì„±ëŠ¥ ìµœì í™”

### 1. DFA ìµœì†Œí™”

**ëª©ì **: ìƒíƒœ ìˆ˜ ìµœì†Œí™”í•˜ì—¬ ë©”ëª¨ë¦¬ì™€ ì†ë„ í–¥ìƒ

**ë°©ë²•**: ë™ë“±í•œ ìƒíƒœ ë³‘í•©

### 2. ì§ì ‘ ì½”ë”© DFA

**Lex ëŒ€ì‹  ì†ìœ¼ë¡œ ì‘ì„±**:

```c
enum State { START, IN_ID, IN_NUM };

Token getNextToken() {
    State state = START;
    char buffer[256];
    int i = 0;

    while (1) {
        char c = getchar();

        switch (state) {
        case START:
            if (isalpha(c) || c == '_') {
                buffer[i++] = c;
                state = IN_ID;
            } else if (isdigit(c)) {
                buffer[i++] = c;
                state = IN_NUM;
            } else if (c == '+') {
                return makeToken(PLUS, "+");
            }
            // ...
            break;

        case IN_ID:
            if (isalnum(c) || c == '_') {
                buffer[i++] = c;
            } else {
                ungetc(c, stdin);
                buffer[i] = '\0';
                return makeToken(ID, buffer);
            }
            break;

        case IN_NUM:
            if (isdigit(c)) {
                buffer[i++] = c;
            } else {
                ungetc(c, stdin);
                buffer[i] = '\0';
                return makeToken(NUMBER, buffer);
            }
            break;
        }
    }
}
```

**ì¥ì **:
- ì™„ì „í•œ ì œì–´
- íŠ¹ìˆ˜ ìµœì í™” ê°€ëŠ¥

**ë‹¨ì **:
- ìœ ì§€ë³´ìˆ˜ ì–´ë ¤ì›€
- ì˜¤ë¥˜ ê°€ëŠ¥ì„±

### 3. ë²„í¼ë§

**ì´ì¤‘ ë²„í¼ (Two-Buffer Scheme)**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Buffer 1  â”‚ Buffer 2  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†‘
 forward ptr

- forwardê°€ ë²„í¼ ëì— ë„ë‹¬í•˜ë©´ ë‹¤ìŒ ë²„í¼ë¡œ ì „í™˜
- I/O íšŸìˆ˜ ê°ì†Œ
```

---

## í•µì‹¬ ì •ë¦¬

### ì–´íœ˜ ë¶„ì„ì˜ ì—­í• 

1. **í† í°í™”**: ë¬¸ì ìŠ¤íŠ¸ë¦¼ â†’ í† í° ìŠ¤íŠ¸ë¦¼
2. **ì „ì²˜ë¦¬**: ê³µë°±, ì£¼ì„ ì œê±°
3. **ì—ëŸ¬ ê²€ì¶œ**: ì˜ëª»ëœ ë¬¸ì ë°œê²¬

### ì£¼ìš” ê°œë…

| ê°œë… | ì„¤ëª… |
|------|------|
| **í† í°** | ì˜ë¯¸ ìˆëŠ” ë‹¨ìœ„ì˜ ë²”ì£¼ |
| **ë ‰ì‹¬** | í† í°ì˜ ì‹¤ì œ ë¬¸ìì—´ |
| **íŒ¨í„´** | í† í°ì„ ì¸ì‹í•˜ëŠ” ê·œì¹™ (ì •ê·œì‹) |
| **ì •ê·œ í‘œí˜„ì‹** | íŒ¨í„´ í‘œí˜„ ì–¸ì–´ |
| **NFA** | ë¹„ê²°ì •ì  ìœ í•œ ì˜¤í† ë§ˆíƒ€ |
| **DFA** | ê²°ì •ì  ìœ í•œ ì˜¤í† ë§ˆíƒ€ |
| **Lex/Flex** | ì–´íœ˜ ë¶„ì„ê¸° ìƒì„±ê¸° |

### ì„¤ê³„ ì›ì¹™

1. **ìµœì¥ ë§¤ì¹­**: ê°€ëŠ¥í•œ ê¸´ ë ‰ì‹¬
2. **ì„ í–‰ ë§¤ì¹­**: ë¨¼ì € ì •ì˜ëœ ê·œì¹™ ìš°ì„ 
3. **í‚¤ì›Œë“œ ìš°ì„ **: í‚¤ì›Œë“œë¥¼ ì‹ë³„ìë³´ë‹¤ ë¨¼ì €

### Lex/Flex ì‚¬ìš©

**ì¥ì **:
- ìë™ DFA ìƒì„±
- ì„ ì–¸ì  ëª…ì„¸
- ì˜¤ë¥˜ ê°€ëŠ¥ì„± ê°ì†Œ

**ë‹¨ì **:
- ìƒì„± ì½”ë“œ í¬ê¸°
- ë””ë²„ê¹… ì–´ë ¤ì›€
- íŠ¹ìˆ˜ ìµœì í™” ì œí•œ

---

ë‹¤ìŒ í¬ìŠ¤íŠ¸ì—ì„œëŠ” **êµ¬ë¬¸ ë¶„ì„(Syntax Analysis) Part 1**ì„ ë‹¤ë£¹ë‹ˆë‹¤. í† í° ìŠ¤íŠ¸ë¦¼ì„ ë°›ì•„ ë¬¸ë²•ì„ ê²€ì¦í•˜ê³  íŒŒìŠ¤ íŠ¸ë¦¬ë¥¼ ìƒì„±í•˜ëŠ” ê³¼ì •ì„ í•™ìŠµí•©ë‹ˆë‹¤!
