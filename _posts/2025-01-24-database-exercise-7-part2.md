---
title: "[데이터베이스] 문제 해설 #7 Part 2 - 정규화 고급 주제"
date: 2025-01-24 14:30:00 +0900
categories: [Computer Science, Database Systems]
tags: [normalization, bcnf, 3nf, 2nf, 4nf, dependency-preservation, algorithm, sql, null-values]
pin: false
math: true
mermaid: false
---

## 개요

이 포스트는 **관계형 데이터베이스 설계(Relational Database Design)** 연습 문제 Part 2로, **정규화의 고급 주제**를 다룹니다. Part 1에서 다룬 기초 개념을 바탕으로 효율적인 알고리즘, SQL 구현, NULL 값 처리, BCNF/3NF 분해의 실무적 측면, 그리고 2NF와 4NF까지 확장된 정규화 이론을 학습합니다.

**Part 2에서 다루는 문제:**
- 7.8: 효율적인 속성 클로저 계산 알고리즘
- 7.9: 함수적 종속성 검증을 위한 SQL 쿼리
- 7.10: 무손실 분해에서 NULL 값의 영향
- 7.11: BCNF 분해와 기본키/외래키 제약조건
- 7.12: 무손실 분해의 증명 (일반화)
- 7.13: 종속성 보존 분해
- 7.14-7.15: 정준 커버의 유일성
- 7.16: 무손실 3NF 분해 보장
- 7.17: 여러 개의 BCNF 분해
- 7.18-7.19: 3NF와 2NF의 정의
- 7.20: BCNF이지만 4NF가 아닌 예제

---

## 문제 7.8: 효율적인 클로저 계산 알고리즘

### 문제
Figure 7.19(7.18)의 α⁺를 계산하는 알고리즘을 고려하시오. 이 알고리즘이 Figure 7.8(Section 7.4.2)에 제시된 알고리즘보다 더 효율적임을 보이고, α⁺를 올바르게 계산함을 증명하시오.

### 알고리즘 구조

**Figure 7.19의 알고리즘:**
```
result := ∅;
fdcount[i] := |β|  // i번째 FD β → γ의 좌변 속성 개수
appears[A] := i번째 FD의 좌변에 A가 나타나는 FD들의 리스트

addin(α);

procedure addin(β):
    for each attribute A in β:
        if A ∉ result:
            result := result ∪ {A}
            for each i in appears[A]:
                fdcount[i] := fdcount[i] - 1
                if fdcount[i] = 0:
                    let β → γ be the i-th FD
                    addin(γ)
```

### 정확성 증명

**증명 1: result에 추가된 속성 A에 대해 α → A가 성립**
- α → α는 자명하게 참 (반사 규칙)
- A ∉ α가 result에 추가되려면, β → γ인 FD가 존재하고 A ∈ γ이며 β ⊆ result여야 함
- 귀납법으로, result의 모든 속성에 대해 α → result가 성립함을 보일 수 있음

**증명 2: A ∈ α⁺이면 A는 최종적으로 result에 추가됨**
- Armstrong 공리로 α → A를 증명하는 단계 수에 대한 귀납법 사용
- **기본 사례**: A ∈ α이면, addin(α) 호출 시 A가 즉시 추가됨
- **귀납 단계**: n+1 단계로 α → A를 증명할 수 있다면:
  - 마지막 단계가 반사/증강 규칙이면, A는 이미 n번째 단계에서 result에 포함됨
  - 마지막 단계가 추이 규칙 (β → γ 사용)이면:
    - 귀납 가정에 의해 β ⊆ result
    - 따라서 fdcount[i] = 0이 되고, A ∈ γ가 result에 추가됨

### 효율성 분석

**시간 복잡도:**
- **Figure 7.8 알고리즘**: O(|F|²)
  - 각 반복마다 모든 FD를 검사
  - 최대 |F|번 반복 가능

- **Figure 7.19 알고리즘**: O(|F|)
  - 각 FD를 초기화 시 1번 검사
  - appears 배열 크기 = O(|F|)
  - addin의 재귀 호출은 appears 크기에 비례하여 선형 시간

**공간 복잡도:**
- fdcount 배열: O(|F|)
- appears 배열: O(|F| × 평균 FD 좌변 크기)

### 실제 예제

**FD 집합 F:**
```
A → BC
CD → E
B → D
E → A
```

**A⁺ 계산 과정:**

| 단계 | result | fdcount 변화 | 설명 |
|------|--------|--------------|------|
| 초기 | ∅ | [2,2,1,1] | A→BC(2), CD→E(2), B→D(1), E→A(1) |
| 1 | {A} | [1,2,1,1] | A가 A→BC의 좌변에 있으므로 fdcount[0]-- |
| 2 | {A,B,C} | [0,2,0,1] | fdcount[0]=0 → BC 추가, B가 B→D 좌변 |
| 3 | {A,B,C,D} | [0,1,0,1] | fdcount[2]=0 → D 추가 |
| 4 | {A,B,C,D,E} | [0,0,0,1] | CD ⊆ result → fdcount[1]=0 → E 추가 |
| 종료 | {A,B,C,D,E} | - | A는 후보키 |

---

## 문제 7.9: SQL로 함수적 종속성 검증

### 문제
데이터베이스 스키마 R(A, B, C)와 관계 r이 주어질 때:
1. 함수적 종속성 B → C가 r에서 성립하는지 테스트하는 SQL 쿼리 작성
2. 이 FD를 강제하는 SQL assertion 작성 (NULL 값이 없다고 가정)

### 해답

#### (a) 검증 쿼리

```sql
SELECT B
FROM r
GROUP BY B
HAVING COUNT(DISTINCT C) > 1
```

**동작 원리:**
- B 값으로 그룹화
- 각 B 값에 대해 서로 다른 C 값의 개수를 센다
- COUNT(DISTINCT C) > 1이면 B → C 위반
- **결과가 비어있으면** B → C 성립
- **결과가 있으면** B → C 위반

**예제:**

| A | B | C |
|---|---|---|
| a₁ | b₁ | c₁ |
| a₂ | b₁ | c₁ |
| a₃ | b₂ | c₂ |

위 데이터에서 쿼리를 실행하면 **빈 결과** → B → C 성립

| A | B | C |
|---|---|---|
| a₁ | b₁ | c₁ |
| a₂ | b₁ | c₂ |
| a₃ | b₂ | c₃ |

위 데이터에서 쿼리를 실행하면 **B=b₁ 반환** → B → C 위반

#### (b) Assertion으로 강제

```sql
CREATE ASSERTION b_to_c CHECK
(NOT EXISTS
    (SELECT B
     FROM r
     GROUP BY B
     HAVING COUNT(DISTINCT C) > 1
    )
)
```

**특징:**
- 삽입/수정/삭제 시 자동으로 검증
- 위반 시 트랜잭션 롤백
- 현재 대부분의 DBMS는 assertion을 지원하지 않음 (표준이지만)
- 대안: **트리거(Trigger)** 사용

#### 트리거 대안

```sql
-- PostgreSQL 예제
CREATE OR REPLACE FUNCTION check_b_to_c()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT B
        FROM r
        GROUP BY B
        HAVING COUNT(DISTINCT C) > 1
    ) THEN
        RAISE EXCEPTION 'Functional dependency B → C violated';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enforce_b_to_c
AFTER INSERT OR UPDATE ON r
FOR EACH STATEMENT
EXECUTE FUNCTION check_b_to_c();
```

---

## 문제 7.10: 무손실 분해와 NULL 값

### 문제
무손실 분해에 대한 논의는 함수적 종속성의 좌변 속성들이 NULL 값을 가질 수 없다고 암묵적으로 가정했습니다. 이 속성이 위반되면 분해 시 무엇이 잘못될 수 있는지 설명하시오.

### 해답

#### NULL 값과 자연 조인

자연 조인의 정의:
- 카티션 곱과 선택 연산으로 정의됨
- 선택 연산은 NULL 값에 대해 **unknown**을 반환
- 따라서 자연 조인은 **공통 속성에 NULL 값을 가진 튜플을 최종 결과에서 제외**

#### 문제 발생 시나리오

**원본 관계 r(A, B, C):**

| A | B | C |
|---|---|---|
| NULL | b₁ | c₁ |
| a₂ | b₂ | c₂ |

**A → BC를 사용한 분해:**
- r₁(A, B)
- r₂(A, C)

**분해된 관계:**

**r₁(A, B):**

| A | B |
|---|---|
| NULL | b₁ |
| a₂ | b₂ |

**r₂(A, C):**

| A | C |
|---|---|
| NULL | c₁ |
| a₂ | c₂ |

**r₁ ⋈ r₂ 계산:**

| A | B | C |
|---|---|---|
| a₂ | b₂ | c₂ |

**결과:**
- 원본 관계 r에 있던 첫 번째 튜플 (NULL, b₁, c₁)이 **손실됨**
- NULL = NULL 비교가 unknown을 반환하므로 조인 조건을 만족하지 못함

#### 안전한 경우

**우변(종속자)만 NULL인 경우:**
- 좌변 속성들이 NULL이 아니면 무손실 분해 보장
- 예: A → B에서 B가 NULL이어도 A가 NULL이 아니면 안전

**결론:**
- 무손실 분해의 증명은 **FD 좌변 속성에 NULL이 없음**을 가정
- 좌변에 NULL이 있으면 일반적인 무손실 분해와 다른 방식의 **손실(lossy)** 발생

---

## 문제 7.11: BCNF 분해와 제약조건

### 문제
BCNF 분해 알고리즘에서 함수적 종속성 α → β를 사용하여 r(α, β, γ)를 r₁(α, β)와 r₂(α, γ)로 분해한다고 가정합시다.

**(a)** 분해된 관계에서 기대되는 기본키와 외래키 제약조건은?
**(b)** 외래키 제약조건이 강제되지 않으면 발생할 수 있는 비일관성의 예는?
**(c)** 3NF 분해 알고리즘을 사용할 때 기대되는 기본키/외래키 종속성은?

### 해답

#### (a) BCNF 분해의 제약조건

**기본키:**
- r₁에서 α는 기본키여야 함 (α → β이므로)

**외래키:**
- r₂의 α 속성들은 r₁의 α를 참조하는 외래키여야 함
- 참조 무결성: r₂의 모든 α 값은 r₁의 α에 존재해야 함

**예제:**
```
원본: instructor(ID, name, dept_name, salary)
FD: ID → name, salary

분해:
r₁: instructor_info(ID, name, salary)  -- ID는 기본키
r₂: instructor_dept(ID, dept_name)     -- ID는 기본키이자 r₁을 참조하는 외래키
```

#### (b) 외래키 미강제 시 문제

**시나리오:**

**r₁(ID, name):**

| ID | name |
|----|------|
| 1 | Kim |
| 2 | Lee |

**r₂(ID, dept_name):**

| ID | dept_name |
|----|-----------|
| 1 | CS |
| 2 | Math |
| 3 | Physics |

**문제:**
- r₁에서 ID=1을 삭제
- r₂에 ID=1이 여전히 존재 (외래키 제약조건 없음)
- **결과**: 원본 관계에서 튜플을 삭제하는 대신 α 값을 NULL로 설정하는 것과 같은 효과
- **비일관성**: r₂의 ID=1은 대응되는 instructor 정보가 없는 "dangling reference"

**올바른 동작 (외래키 강제 시):**
- CASCADE: r₁에서 삭제 시 r₂에서도 자동 삭제
- RESTRICT: r₂에 참조가 있으면 r₁에서 삭제 불가

#### (c) 3NF 분해의 제약조건

**3NF 분해 알고리즘 (Section 7.5.2):**

1. **각 FD α → β에 대해:**
   - 스키마 rᵢ(αβ) 생성
   - α를 기본키로 설정

2. **후보키 보존:**
   - 원본 관계의 후보키 γ가 어떤 새 관계 rₖ에 포함됨
   - γ를 rₖ의 기본키로 설정

3. **외래키 제약조건:**
   - 각 관계 rᵢ에 대해:
   - rᵢ의 기본키 속성들이 다른 관계 rⱼ에도 나타나면
   - rⱼ에서 rᵢ를 참조하는 외래키 제약조건 생성

**예제:**
```
R(A, B, C, D)
F = {A → B, B → C, C → D}

3NF 분해:
r₁(A, B)  -- A: 기본키
r₂(B, C)  -- B: 기본키, r₁.B 참조 (외래키)
r₃(C, D)  -- C: 기본키, r₂.C 참조 (외래키)
r₄(A, C, D)  -- A: 기본키 (원본의 후보키 보존)
```

---

## 문제 7.12: 무손실 분해의 일반 증명

### 문제
R₁, R₂, ..., Rₙ이 스키마 U의 분해라 하자. u(U)를 관계라 하고, rᵢ = ΠRᵢ(u)라 할 때, 다음을 증명하시오:

**u ⊆ r₁ ⋈ r₂ ⋈ ... ⋈ rₙ**

### 증명

**목표**: 모든 튜플 t ∈ u에 대해, t ∈ r₁ ⋈ r₂ ⋈ ... ⋈ rₙ임을 보이기

#### 단계 1: 프로젝션의 성질

t ∈ u이면:
- rᵢ = ΠRᵢ(u) → t[Rᵢ] ∈ rᵢ (모든 i = 1, 2, ..., n)

#### 단계 2: 자연 조인의 정의

```
t[R₁] ⋈ t[R₂] ⋈ ... ⋈ t[Rₙ]
= Π_U(σ_θ(t[R₁] × t[R₂] × ... × t[Rₙ]))
```

여기서:
- θ는 "같은 이름을 가진 속성들의 값이 같다"는 조건
- U = R₁ ∪ R₂ ∪ ... ∪ Rₙ (분해의 정의)

#### 단계 3: 단일 튜플의 카티션 곱

**단일 튜플들의 카티션 곱은 하나의 튜플을 생성:**
- t[R₁] × t[R₂] × ... × t[Rₙ] = 하나의 큰 튜플

#### 단계 4: 선택 조건 만족

**θ 조건이 자동으로 만족됨:**
- 모든 t[Rᵢ]는 동일한 원본 튜플 t에서 프로젝션됨
- 따라서 같은 이름의 속성은 같은 값을 가짐
- σ_θ는 튜플을 그대로 통과시킴

#### 단계 5: 프로젝션

**Π_U는 중복 속성 제거:**
- 분해의 정의: U = R₁ ∪ R₂ ∪ ... ∪ Rₙ
- 모든 t의 속성들이 결과에 포함됨
- 중복 속성 이름 제거 후 결과 = t

#### 결론

t[R₁] ⋈ t[R₂] ⋈ ... ⋈ t[Rₙ] = t

따라서:
- t ∈ u이면 t ∈ r₁ ⋈ r₂ ⋈ ... ⋈ rₙ
- 모든 t에 대해 성립하므로: **u ⊆ r₁ ⋈ r₂ ⋈ ... ⋈ rₙ**

**주의**: 이것은 분해가 **추가 튜플을 생성하지 않음**을 보장하지는 않습니다. 무손실 분해가 되려면 **u = r₁ ⋈ r₂ ⋈ ... ⋈ rₙ**이어야 하며, 이는 추가 조건 (예: R₁ ∩ R₂ → R₁ 또는 R₁ ∩ R₂ → R₂)이 필요합니다.

---

## 문제 7.13: 종속성 보존 분해

### 문제
Exercise 7.1의 분해가 종속성 보존 분해가 아님을 보이시오.

### 해답

#### 원본 스키마 (Exercise 7.1)

**R = (A, B, C, D, E)**

**FD 집합 F:**
```
A → BC
CD → E
B → D
E → A
```

**분해:**
- R₁ = (A, B, C)
- R₂ = (A, D, E)

#### F₁ 계산 (R₁에 대한 F의 제한)

F₁ = F의 FD들 중 R₁의 속성만 포함하는 것들의 클로저

**R₁ = (A, B, C)의 속성만 사용:**
- A → BC ✓ (모든 속성이 R₁에 있음)
- A → B ✓ (분해 규칙)
- A → C ✓ (분해 규칙)
- A → AB, A → AC, A → ABC 등 (증강/합집합)
- B → B, C → C 등 (자명한 FD)
- AB → AC, AB → ABC 등

**F₁⁺에서 D를 포함하는 FD는 없음** (D ∉ R₁)

#### F₂ 계산 (R₂에 대한 F의 제한)

F₂ = F의 FD들 중 R₂의 속성만 포함하는 것들의 클로저

**R₂ = (A, D, E)의 속성만 사용:**
- E → A ✓ (모든 속성이 R₂에 있음)
- A → ADE (A⁺ = ABCDE이므로, R₂로 제한하면 ADE)
- 기타 자명한 FD들

**F₂⁺에서 B를 좌변으로 하는 FD는 없음** (B ∉ R₂)

#### B → D 보존 확인

**종속성 보존을 위해:**
- B → D를 (F₁ ∪ F₂)⁺에서 유도할 수 있어야 함

**F₁에서:**
- B를 포함하지만 D는 없음
- B → α 형태의 FD가 있다면 α ⊆ {A, B, C}

**F₂에서:**
- D를 포함하지만 B는 없음
- β → D 형태의 FD가 있다면 β ⊆ {A, D, E}

**추이 규칙 적용 시도:**
- B → D를 유도하려면:
  - B → α (F₁⁺에서) 및 α → D (F₂⁺에서) 필요
  - 교집합 R₁ ∩ R₂ = {A}이므로 α = A여야 함
  - 즉, B → A와 A → D가 필요

**확인:**
- B⁺ (F₁에서) = {B} ∪ ... (A를 포함하지 않음)
- B → D는 유도 불가능

#### 결론

**B → D는 보존되지 않음** → 이 분해는 종속성 보존 분해가 아님

**실무적 영향:**
- B → D를 검증하려면 R₁과 R₂를 조인해야 함
- 삽입/수정 시 성능 저하
- 무결성 검증 비용 증가

---

## 문제 7.14-7.15: 정준 커버의 유일성

### 문제 7.14
주어진 FD 집합에 대해 여러 개의 정준 커버가 존재할 수 있음을 다음 종속성을 사용하여 보이시오:

**X → YZ, Y → XZ, Z → XY**

### 해답 7.14

#### 정준 커버 1

**초기:** X → YZ, Y → XZ, Z → XY

**X → YZ에서 Z 제거:**
- X⁺ (X → Y 사용) = {X, Y, X, Z} (Y → XZ 사용)
- Z는 여분 → 제거
- 결과: X → Y

**Y → XZ에서 X 제거:**
- Y⁺ (Y → Z 사용) = {Y, Z, X, Y} (Z → XY 사용)
- X는 여분 → 제거
- 결과: Y → Z

**Z → XY에서 Y 제거:**
- Z⁺ (Z → X 사용) = {Z, X, Y, Z} (X → YZ 사용)
- Y는 여분 → 제거
- 결과: Z → X

**정준 커버 1: X → Y, Y → Z, Z → X**

#### 정준 커버 2

**초기:** X → YZ, Y → XZ, Z → XY

**X → YZ에서 Y 제거:**
- X⁺ (X → Z 사용) = {X, Z, X, Y} (Z → XY 사용)
- Y는 여분 → 제거
- 결과: X → Z

**Y → XZ에서 Z 제거:**
- Y⁺ (Y → X 사용) = {Y, X, Y, Z} (X → YZ 사용)
- Z는 여분 → 제거
- 결과: Y → X

**Z → XY에서 X 제거:**
- Z⁺ (Z → Y 사용) = {Z, Y, X, Z} (Y → XZ 사용)
- X는 여분 → 제거
- 결과: Z → Y

**정준 커버 2: X → Z, Y → X, Z → Y**

#### 결론

**두 정준 커버는 서로 다르지만 모두 유효함:**
- Fᶜ₁ = {X → Y, Y → Z, Z → X}
- Fᶜ₂ = {X → Z, Y → X, Z → Y}
- 둘 다 원본 FD 집합과 논리적으로 동등
- 정준 커버는 **유일하지 않음**

### 문제 7.15

정준 커버 생성 알고리즘이 한 번에 하나의 여분 속성만 제거하는 이유를 Exercise 7.14의 FD를 사용하여 설명하시오.

### 해답 7.15

#### 잘못된 접근: 동시 제거

**X → YZ에서:**
- Y가 여분임을 확인 (X → Z 사용, Z → XY로 Y 유도)
- Z가 여분임을 확인 (X → Y 사용, Y → XZ로 Z 유도)
- **두 속성 모두 제거하면:** X → ∅ (자명한 FD)

**문제:**
- Y와 Z를 동시에 제거하면 X → YZ를 더 이상 유도할 수 없음
- 손실이 발생

#### 올바른 접근: 순차 제거

**Y 제거:**
- X → YZ에서 Y 제거 → X → Z
- 이제 Z는 더 이상 여분이 아님 (X⁺ = {X, Z}만 가능, Y 유도 불가)

**또는 Z 제거:**
- X → YZ에서 Z 제거 → X → Y
- 이제 Y는 더 이상 여분이 아님 (X⁺ = {X, Y}만 가능, Z 유도 불가)

#### 상호 의존성

**Y와 Z의 여분 여부는 서로 의존적:**
- Y가 여분인지 확인할 때 Z의 존재를 가정
- Z가 여분인지 확인할 때 Y의 존재를 가정
- 하나를 제거하면 다른 것이 더 이상 여분이 아니게 됨

#### 알고리즘 설계 원칙

**정준 커버 알고리즘:**
```
for each FD α → β in F:
    for each attribute A in β:
        if A is extraneous:
            remove A from β
```

**한 번에 하나씩 제거:**
- 각 제거 후 재평가
- 상호 의존성 문제 방지
- 안전한 정준 커버 생성

---

## 문제 7.16: 무손실 3NF 분해 보장

### 문제
종속성 보존 3NF 분해가 무손실 분해임을 보장할 수 있음을 증명하시오. 힌트: 분해된 스키마 중 적어도 하나가 분해되는 스키마의 후보키를 포함함을 보장하면 됨. (힌트: 모든 프로젝션의 조인이 원본 관계보다 더 많은 튜플을 가질 수 없음을 보이시오.)

### 증명

#### 설정

- F: 스키마 R에 대한 FD 집합
- σ = {R₁, R₂, ..., Rₙ}: R의 종속성 보존 3NF 분해
- X: R의 후보키

#### 목표

**u = ΠX(u) ⋈ ΠR₁(u) ⋈ ΠR₂(u) ⋈ ... ⋈ ΠRₙ(u)** 임을 증명

(Exercise 7.12에서 ⊆는 이미 증명됨, ⊇를 증명해야 함)

#### 전략

**두 튜플 t₁, t₂ ∈ j에 대해:**
- t₁[X] = t₂[X]이면 t₁ = t₂임을 보이기
- 이것이 성립하면 |ΠX(j)| = |j|
- ΠX(j) = ΠX(u) = u (X는 후보키)
- 따라서 |j| = |u|
- Exercise 7.12와 결합하면 u = j

#### 귀납적 증명

**F' = F₁ ∪ F₂ ∪ ... ∪ Fₙ** (각 Fᵢ는 F의 Rᵢ에 대한 제한)

**X⁺ 계산 알고리즘 (Figure 7.8) 사용:**

**기본 사례:**
- result ← X
- t₁[X] = t₂[X]이므로 t₁[result] = t₂[result] ✓

**귀납 단계:**
- k번째 루프 끝에 t₁[result] = t₂[result]이 참이라 가정
- k+1번째 루프에서 FD α → β를 고려 (α ⊆ result)
- α → β는 어떤 Rᵢ에서 성립
- t₁[Rᵢ], t₂[Rᵢ] ∈ ΠRᵢ(u)
- t₁[α] = t₂[α] (α ⊆ result)
- α → β가 Rᵢ에서 성립하므로 t₁[β] = t₂[β]
- result ← result ∪ β
- t₁[result] = t₂[result] ✓ (k+1번째 루프 끝)

**결론:**
- σ가 종속성 보존이고 X가 R의 키이므로:
- 알고리즘 종료 시 result = R
- t₁[R] = t₂[R] → t₁ = t₂

#### 3NF 분해 알고리즘 적용

**Section 7.5.2 알고리즘:**
- 후보키가 없는 스키마가 생성되면
- X (후보키)를 포함하는 스키마 추가
- 이것이 무손실 분해를 보장

**결과:**
- σ ∪ {X}는 무손실 종속성 보존 3NF 분해
- X는 자명하게 3NF

---

## 문제 7.17: 여러 개의 BCNF 분해

### 문제
관계 스키마 R'와 FD 집합 F'가 주어졌을 때, R'의 BCNF로의 무손실 분해가 적어도 3개 이상 존재하는 예를 제시하시오.

### 해답

#### 예제 설정

**R' = (A, B, C, D)**

**F' = {A → B, C → D, B → C}**

#### 분해 1

**단계 1:** A → B 사용
- R₁ = (A, B)
- R₂ = (A, C, D)

**단계 2:** R₂에서 C → D 사용
- R₂₁ = (C, D)
- R₂₂ = (A, C)

**분해 1: {(A, B), (C, D), (A, C)}**

**검증:**
- (A, B): A → B이고 A는 (A, B)의 키 → BCNF ✓
- (C, D): C → D이고 C는 (C, D)의 키 → BCNF ✓
- (A, C): 비자명 FD 없음 → BCNF ✓

#### 분해 2

**단계 1:** C → D 사용
- R₁ = (C, D)
- R₂ = (A, B, C)

**단계 2:** R₂에서 A → B 사용
- R₂₁ = (A, B)
- R₂₂ = (A, C)

**분해 2: {(A, B), (C, D), (A, C)}** (동일한 결과)

#### 분해 3

**단계 1:** B → C 사용
- R₁ = (B, C)
- R₂ = (A, B, D)

**단계 2:** R₂에서 A → B 사용
- R₂₁ = (A, B)
- R₂₂ = (A, D)

**분해 3: {(B, C), (A, D), (A, B)}**

**검증:**
- (B, C): B → C이고 B는 (B, C)의 키 → BCNF ✓
- (A, D): 비자명 FD 없음 → BCNF ✓
- (A, B): A → B이고 A는 (A, B)의 키 → BCNF ✓

#### 결론

**3개의 서로 다른 BCNF 분해:**
1. {(A, B), (C, D), (A, C)}
2. {(A, B), (C, D), (A, C)} (순서만 다름)
3. {(B, C), (A, D), (A, B)}

**특징:**
- 모두 무손실 분해
- 모두 BCNF
- 사용하는 FD의 순서에 따라 다른 결과
- 일부는 종속성 보존, 일부는 아닐 수 있음

---

## 문제 7.18-7.19: 3NF와 2NF

### 문제 7.18

**Prime attribute**: 적어도 하나의 후보키에 나타나는 속성
**Transitive dependency**: α → β이고 β → α가 아니며, A ∉ α, A ∉ β인 속성 A에 대해 β → A가 성립할 때, A는 α에 대해 transitively dependent함

**3NF의 재정의:**
관계 스키마 R은 FD 집합 F에 대해 3NF라고 하는 것은, R의 모든 nonprime 속성 A가 R의 어떤 키에 대해서도 transitively dependent하지 않을 때이다.

이 새로운 정의가 원래 정의와 동등함을 보이시오.

### 해답 7.18

#### 정의 확인

**Textbook 정의 (3NF):**
FD α → β에 대해 다음 중 하나를 만족:
1. α → β가 자명함
2. α는 슈퍼키
3. β - α의 각 속성이 어떤 후보키에 포함됨 (prime)

**Exercise 정의 (3NF):**
nonprime 속성 A가 어떤 키에 대해서도 transitively dependent하지 않음

#### 방향 1: Textbook → Exercise

**가정:** R이 textbook 정의로 3NF
**보일 것:** nonprime A가 키 γ에 대해 transitively dependent하지 않음

**귀류법:**
- A가 γ에 대해 transitively dependent라 가정
- 그러면 β가 존재하여: γ → β, β → A, β → γ는 거짓, A ∉ γ, A ∉ β

**β → A 분석:**
- A ∉ β이므로 β → A는 비자명
- β → γ가 거짓이므로 β는 슈퍼키가 아님
- A는 nonprime이므로 어떤 후보키에도 없음
- **따라서 β → A는 textbook 정의의 모든 조건을 위반** ✗

**모순** → A는 transitively dependent할 수 없음

#### 방향 2: Exercise → Textbook

**가정:** R이 exercise 정의로 3NF
**보일 것:** R이 textbook 정의로 3NF

**귀류법:**
- α → β가 textbook 정의의 모든 조건을 위반한다고 가정
- α → β는 비자명
- α는 슈퍼키가 아님
- β - α의 어떤 A가 nonprime

**γ를 후보키라 하자:**
- γ → α (γ는 슈퍼키)
- α → γ는 거짓 (α는 슈퍼키 아님)
- A ∉ γ (A는 nonprime)
- A ∉ α (α → β는 비자명이고 A ∈ β - α)

**따라서 A는 γ에 대해 transitively dependent** ✗

**모순** → textbook 정의 만족

#### 결론

두 정의는 **논리적으로 동등**

### 문제 7.19

**Partial dependency**: α → β에서 α의 진부분집합 γ가 존재하여 γ → β일 때, β는 α에 부분적으로 의존(partially dependent)

**2NF (Second Normal Form):**
관계 스키마 R이 2NF인 것은 R의 각 속성 A가 다음 조건 중 하나를 만족하는 경우:
1. A가 후보키에 나타남 (prime)
2. A가 어떤 후보키에도 부분적으로 의존하지 않음

모든 3NF 스키마가 2NF임을 보이시오. (힌트: 모든 partial dependency는 transitive dependency임을 보이시오.)

### 해답 7.19

#### 정의 재확인

**2NF:** nonprime A가 어떤 후보키에도 부분적으로 의존하지 않음
**3NF (Exercise 7.18):** nonprime A가 어떤 키에도 transitively dependent하지 않음

#### 증명

**Lemma:** A가 후보키 α에 부분적으로 의존하면, A는 α에 대해 transitively dependent함

**증명:**

**가정:**
- A가 α에 부분적으로 의존
- γ ⊂ α (진부분집합)이고 γ → A

**보일 것:** A는 α에 대해 transitively dependent

**조건 확인:**
1. α → γ ✓ (γ ⊂ α이므로 반사 규칙)
2. γ → A ✓ (주어짐)
3. γ → α?
   - γ ⊂ α (진부분집합)
   - α는 후보키 (minimal)
   - 따라서 γ → α는 거짓 ✓
4. A ∉ α?
   - A가 α에 부분적으로 의존
   - A는 nonprime이어야 함 (2NF 정의)
   - 따라서 A ∉ α ✓
5. A ∉ γ?
   - A ∈ γ이면 γ → A는 자명
   - 하지만 partial dependency는 비자명 FD를 의미
   - 따라서 A ∉ γ ✓

**모든 조건 만족** → A는 α에 대해 transitively dependent

#### 주 정리

**모든 3NF 스키마는 2NF:**

**증명 (귀류법):**
- R이 3NF지만 2NF가 아니라고 가정
- nonprime A가 후보키 α에 부분적으로 의존
- Lemma에 의해 A는 α에 대해 transitively dependent
- **이것은 R이 3NF라는 가정에 모순** ✗

**결론:** 3NF ⊆ 2NF

---

## 문제 7.20: BCNF이지만 4NF가 아닌 예제

### 문제
관계 스키마 R과 종속성 집합이 주어졌을 때, R이 BCNF이지만 4NF가 아닌 예를 제시하시오.

### 해답

#### 4NF 개념

**Multivalued Dependency (MVD):** α ↠ β
- α 값이 결정되면 β 값의 집합이 결정됨
- 다른 속성들과 독립적

**4NF:** 모든 비자명 MVD α ↠ β에 대해 α가 슈퍼키

#### 예제

**R = (A, B, C)**

**유일한 비자명 종속성:** A ↠ B (MVD)

#### BCNF 확인

**FD 분석:**
- 유일한 비자명 FD: A → B
- A는 (A, B, C)의 후보키
- **따라서 R은 BCNF** ✓

**설명:**
- A → B에서 A는 슈퍼키가 되려면 A → ABC여야 함
- A → C는 성립하지 않지만, A와 B가 함께 C를 결정
- 실제로 AB → C이고 AB는 슈퍼키
- BCNF 만족

#### 4NF 확인

**MVD 분석:**
- A ↠ B (multivalued dependency)
- A는 B의 값 집합을 결정하지만 C와 독립적
- A는 (A, B, C)의 슈퍼키가 아님 (A → C 성립 안 함)
- **따라서 R은 4NF 위반** ✗

#### 실제 데이터 예시

**강사-과목-시간 관계:**

| instructor (A) | course (B) | time (C) |
|----------------|-----------|----------|
| Kim | Database | 9AM |
| Kim | Algorithm | 9AM |
| Kim | Database | 2PM |
| Kim | Algorithm | 2PM |

**특징:**
- Kim이 가르치는 과목: {Database, Algorithm}
- Kim의 가능한 시간: {9AM, 2PM}
- 과목과 시간은 독립적으로 조합됨 (MVD)

**중복 문제:**
- 4개 튜플이 필요 (2과목 × 2시간)
- 과목 추가 시 모든 시간에 대해 튜플 추가 필요
- 시간 추가 시 모든 과목에 대해 튜플 추가 필요

#### 4NF 분해

**분해:**
- R₁(A, B) = instructor_course
- R₂(A, C) = instructor_time

**R₁:**

| instructor | course |
|------------|--------|
| Kim | Database |
| Kim | Algorithm |

**R₂:**

| instructor | time |
|------------|------|
| Kim | 9AM |
| Kim | 2PM |

**이점:**
- 중복 제거
- 과목 추가 시 R₁에만 1개 튜플 추가
- 시간 추가 시 R₂에만 1개 튜플 추가

---

## 학습 정리

### 핵심 개념

1. **효율적 알고리즘**
   - 속성 클로저 계산의 최적화
   - 시간 복잡도: O(|F|²) → O(|F|)

2. **SQL 구현**
   - FD 검증 쿼리
   - Assertion과 Trigger

3. **NULL 값 처리**
   - 무손실 분해 조건 위반
   - 자연 조인의 제약

4. **제약조건 관리**
   - 기본키와 외래키
   - 참조 무결성

5. **분해의 특성**
   - 무손실 분해
   - 종속성 보존 분해
   - 정준 커버의 비유일성

6. **정규형 계층**
   - 4NF ⊂ BCNF ⊂ 3NF ⊂ 2NF ⊂ 1NF
   - 각 정규형의 특징과 차이

### 실무 적용

1. **알고리즘 선택**
   - 대규모 FD 집합: 효율적 알고리즘 사용
   - 성능 vs 정확성 trade-off

2. **무결성 강제**
   - Trigger로 FD 검증
   - 외래키 제약조건 설정

3. **정규화 수준 결정**
   - BCNF: 이론적으로 최선, 종속성 손실 가능
   - 3NF: 종속성 보존, 약간의 중복 허용
   - 2NF: 부분 종속성 제거

4. **비정규화 고려**
   - 성능 요구사항
   - 조인 비용
   - 중복 vs 성능 trade-off

---

## 다음 포스트 예고

다음 포스트에서는 **데이터 저장 구조(Data Storage Structures)**를 다룰 예정입니다:
- 물리적 저장 매체
- 파일 조직과 레코드 구조
- 버퍼 관리
- 저장 공간 할당

관계형 데이터베이스 설계의 논리적 측면에서 물리적 구현으로 진행합니다.
