---
title: "[데이터베이스] 데이터 저장 구조 (Data Storage Structures)"
date: 2025-01-26 14:30:00 +0900
categories: [Computer Science, Database Systems]
tags: [database-storage, file-organization, buffer-management, slotted-page, heap-file, sequential-file, multitable-clustering, column-oriented-storage, data-dictionary]
pin: false
math: true
mermaid: true
---

## 개요

데이터베이스는 데이터를 효율적으로 저장하고 검색하기 위해 다양한 저장 구조를 사용합니다. 이 포스트에서는 파일 조직 방법, 레코드 저장 방식, 버퍼 관리, 그리고 현대적인 열 지향 저장소까지 데이터베이스 저장 구조의 핵심 개념들을 다룹니다.

---

## 1. 파일 조직 (File Organization)

### 1.1 고정 길이 레코드 (Fixed-Length Records)

**특징:**
- 모든 레코드가 동일한 크기를 가짐
- 레코드의 각 필드가 고정된 크기를 가짐
- 간단하고 효율적인 저장 및 접근 방식

**저장 방식:**
```
레코드 1: [필드1][필드2][필드3]
레코드 2: [필드1][필드2][필드3]
레코드 3: [필드1][필드2][필드3]
```

**장점:**
- 레코드 위치 계산이 간단: `offset = record_number × record_size`
- 빠른 직접 접근 가능
- 메모리 관리가 단순함

**단점:**
- 가변 길이 데이터(예: 문자열)를 효율적으로 저장하기 어려움
- 공간 낭비 가능성 (짧은 데이터도 고정 크기 할당)

**삭제 처리:**

1. **방법 1: 이동 방식 (Move Records)**
   - 삭제된 레코드 이후의 모든 레코드를 앞으로 이동
   - 장점: 공간 낭비 없음
   - 단점: 이동 비용이 높음 (O(n))

2. **방법 2: 프리 리스트 (Free List)**
   - 삭제된 레코드 공간을 프리 리스트로 관리
   - 새 레코드 삽입 시 프리 리스트의 공간 재사용
   - 장점: 삭제 및 삽입이 빠름 (O(1))
   - 단점: 파일 내 빈 공간(fragmentation) 발생 가능

```
파일 헤더: [첫 번째 빈 레코드 위치]
         ↓
레코드 1: [데이터]
레코드 2: [삭제됨 → 다음 빈 위치]
레코드 3: [데이터]
레코드 4: [삭제됨 → NULL]
```

### 1.2 가변 길이 레코드 (Variable-Length Records)

**발생 원인:**
1. 가변 길이 필드 (VARCHAR, TEXT 등)
2. 반복 필드 (Repeating Fields)
3. 선택적 필드 (Optional Fields)
4. 다중 레코드 타입이 한 파일에 저장되는 경우

**저장 방식 - Slotted Page 구조:**

```
┌─────────────────────────────────────┐
│        Page/Block Header            │
│  - Number of entries                │
│  - End of free space                │
│  - Location & size of each entry    │
├─────────────────────────────────────┤
│        Slot Array                   │
│  Slot 1: [offset][size]             │
│  Slot 2: [offset][size]             │
│  Slot 3: [offset][size]             │
├─────────────────────────────────────┤
│        Free Space                   │
│                                     │
├─────────────────────────────────────┤
│        Record 3                     │
│        Record 2                     │
│        Record 1                     │
└─────────────────────────────────────┘
```

**Slotted Page 특징:**
- **헤더**: 페이지 메타데이터 (엔트리 수, 자유 공간 끝 위치)
- **슬롯 배열**: 각 레코드의 위치와 크기 정보
- **자유 공간**: 새 레코드 삽입을 위한 빈 공간
- **레코드 영역**: 실제 레코드 데이터 (페이지 끝에서부터 저장)

**장점:**
1. 레코드 이동 시 슬롯만 업데이트하면 되므로 포인터 유지 가능
2. 레코드 크기가 변해도 슬롯 정보만 수정
3. 삭제된 공간 재사용 용이
4. 페이지 내 공간 활용도 최적화

**삽입 및 삭제:**
- **삽입**: 자유 공간에 레코드 추가, 슬롯 배열에 새 엔트리 추가
- **삭제**: 슬롯을 invalid로 표시, 필요 시 공간 압축(compaction)

---

## 2. 파일 내 레코드 조직 (Organization of Records in Files)

### 2.1 힙 파일 조직 (Heap File Organization)

**특징:**
- 레코드가 삽입된 순서대로 저장됨
- 특별한 순서 유지 없음
- 새 레코드는 파일의 끝이나 빈 공간에 삽입

**장점:**
- 삽입이 매우 빠름 (O(1))
- 구현이 단순함
- 오버헤드가 적음

**단점:**
- 특정 레코드 검색 시 전체 파일 스캔 필요 (O(n))
- 범위 검색 비효율적
- 정렬되지 않아 순차 접근 시 성능 저하

**사용 사례:**
- 작은 테이블
- 순서가 중요하지 않은 로그 데이터
- 전체 테이블 스캔이 주 연산인 경우

### 2.2 순차 파일 조직 (Sequential File Organization)

**특징:**
- 레코드가 검색 키(search key) 순서로 정렬되어 저장
- 연결 리스트 구조로 순서 유지

**구조:**
```
[헤더: 첫 레코드 포인터]
    ↓
[레코드 1] → [레코드 2] → [레코드 3] → ...
 (키: 10)     (키: 20)     (키: 30)
```

**장점:**
- 정렬된 키로 빠른 범위 검색 가능
- 순차 접근 시 효율적
- 이진 탐색 가능 (O(log n))

**단점:**
- 삽입/삭제 시 순서 유지를 위한 오버헤드
- 삽입 시 오버플로우 블록 필요 가능
- 주기적인 재조직(reorganization) 필요

**오버플로우 블록:**
- 새 레코드 삽입 시 순서를 깨지 않기 위해 오버플로우 블록 사용
- 주기적으로 파일 재조직하여 오버플로우 블록을 메인 파일에 병합

### 2.3 다중 테이블 클러스터링 (Multitable Clustering File Organization)

**개념:**
- 여러 테이블의 관련된 레코드들을 물리적으로 가까이 저장
- 조인 연산을 최적화하기 위한 저장 방식

**예시: department와 instructor 테이블 클러스터링**

```
┌─────────────────────────────────────┐
│ Department: Computer Science        │
│  - dept_name: "Comp. Sci."          │
│  - building: "Taylor"               │
│  - budget: 100000                   │
├─────────────────────────────────────┤
│  Instructor: Katz                   │
│   - name: "Katz"                    │
│   - salary: 75000                   │
├─────────────────────────────────────┤
│  Instructor: Srinivasan             │
│   - name: "Srinivasan"              │
│   - salary: 65000                   │
├─────────────────────────────────────┤
│ Department: Finance                 │
│  - dept_name: "Finance"             │
│  - building: "Painter"              │
│  - budget: 120000                   │
├─────────────────────────────────────┤
│  Instructor: Wu                     │
│   - name: "Wu"                      │
│   - salary: 90000                   │
└─────────────────────────────────────┘
```

**장점:**
- 조인 연산 시 I/O 비용 대폭 감소
- 관련 데이터가 같은 페이지에 있어 캐시 효율 증가
- 1:N 관계 쿼리에 매우 효율적

**단점:**
- 단일 테이블 스캔 시 불필요한 데이터도 읽음
- 삽입/삭제 시 복잡도 증가
- 공간 낭비 가능 (빈 클러스터 공간)

**적용 사례:**
- 자주 조인되는 테이블들 (예: 주문-주문상세, 부서-직원)
- 1:N 관계의 부모-자식 테이블

### 2.4 테이블 파티셔닝 (Table Partitioning)

**개념:**
- 큰 테이블을 여러 개의 작은 파티션으로 분할
- 각 파티션은 독립적으로 저장 및 관리됨

**파티션 유형:**

1. **범위 파티셔닝 (Range Partitioning)**
   ```sql
   CREATE TABLE sales (
       sale_date DATE,
       amount DECIMAL
   ) PARTITION BY RANGE (sale_date) (
       PARTITION p_2023 VALUES LESS THAN ('2024-01-01'),
       PARTITION p_2024 VALUES LESS THAN ('2025-01-01')
   );
   ```

2. **해시 파티셔닝 (Hash Partitioning)**
   - 해시 함수를 사용해 레코드를 파티션에 분산

3. **리스트 파티셔닝 (List Partitioning)**
   - 특정 값 목록에 따라 파티션 분할

**장점:**
- 쿼리 성능 향상 (파티션 프루닝)
- 병렬 처리 가능
- 관리 용이 (파티션 단위 백업/복구)
- 오래된 데이터 아카이빙 간편

**단점:**
- 파티션 키 선택이 중요
- 파티션 간 조인 시 성능 저하 가능

---

## 3. 데이터 사전 저장소 (Data Dictionary Storage)

**데이터 사전 (Data Dictionary):**
- 데이터베이스의 메타데이터를 저장하는 시스템 카탈로그
- "메타데이터의 데이터베이스"

**저장 정보:**

1. **스키마 정보**
   - 테이블 이름, 컬럼 이름, 데이터 타입
   - 제약조건 (기본키, 외래키, CHECK 등)

2. **인덱스 정보**
   - 인덱스 이름, 타입, 컬럼
   - 인덱스 통계 정보

3. **저장소 정보**
   - 테이블 위치, 파일 구조
   - 파티션 정보

4. **통계 정보**
   - 테이블 크기, 레코드 수
   - 컬럼 분포, 카디널리티
   - 쿼리 최적화에 사용

5. **사용자 및 권한**
   - 사용자 정보
   - 테이블/뷰 접근 권한

**저장 방식:**
- 데이터 사전도 일반 테이블처럼 저장됨
- 시스템 테이블로 관리 (예: PostgreSQL의 `pg_catalog`, MySQL의 `information_schema`)

**쿼리 최적화에서의 역할:**
- 통계 정보를 바탕으로 실행 계획 생성
- 인덱스 선택 결정
- 조인 순서 결정

---

## 4. 저장소 접근과 데이터베이스 버퍼

### 4.1 저장소 계층 구조

```
┌────────────────────────────────────┐
│      CPU Cache (L1/L2/L3)          │  ← 가장 빠름, 가장 작음
├────────────────────────────────────┤
│      Main Memory (RAM)             │  ← 빠름, 휘발성
├────────────────────────────────────┤
│      SSD (Solid State Drive)       │  ← 중간 속도, 비휘발성
├────────────────────────────────────┤
│      HDD (Hard Disk Drive)         │  ← 느림, 대용량
├────────────────────────────────────┤
│      Tape Storage / Archival       │  ← 가장 느림, 가장 큼
└────────────────────────────────────┘
```

**저장소 특성:**
- **메모리**: 빠르지만 비싸고 휘발성
- **디스크**: 느리지만 저렴하고 비휘발성
- **접근 시간 차이**: 메모리는 나노초(ns), 디스크는 밀리초(ms) 단위

### 4.2 데이터베이스 버퍼 (Database Buffer)

**목적:**
- 디스크 I/O를 최소화하여 성능 향상
- 자주 사용되는 데이터를 메모리에 캐싱

**구조:**
```
┌──────────────────────────────────┐
│      Buffer Pool (in Memory)     │
│                                  │
│  ┌──────┐ ┌──────┐ ┌──────┐    │
│  │Block1│ │Block2│ │Block3│    │
│  └──────┘ └──────┘ └──────┘    │
│                                  │
│  ┌──────┐ ┌──────┐ ┌──────┐    │
│  │Block4│ │Block5│ │Block6│    │
│  └──────┘ └──────┘ └──────┘    │
└──────────────────────────────────┘
         ↕ (디스크 I/O)
┌──────────────────────────────────┐
│       Disk Storage               │
└──────────────────────────────────┘
```

**작동 방식:**
1. 데이터 요청 시 먼저 버퍼를 확인
2. **버퍼 히트 (Buffer Hit)**: 데이터가 버퍼에 있으면 바로 반환
3. **버퍼 미스 (Buffer Miss)**: 데이터가 없으면 디스크에서 읽어 버퍼에 저장
4. 버퍼가 꽉 차면 교체 정책에 따라 블록 교체

---

## 5. 버퍼 관리자 (Buffer Manager)

### 5.1 핵심 개념

**버퍼 관리자의 역할:**
1. 버퍼 공간 할당 및 해제
2. 블록 교체 정책 구현
3. 동시성 제어 (핀/언핀, 락)
4. 더티 페이지 관리 (디스크 쓰기)

### 5.2 핀닝 (Pinning)

**개념:**
- 블록을 버퍼에 고정하여 교체되지 않도록 보호

**용도:**
1. 트랜잭션이 블록을 사용 중일 때
2. 로그 기록 전까지 더티 페이지 유지
3. 인덱스 구조 탐색 중

**작동 방식:**
```
pin_count = 0  → 교체 가능
pin_count > 0  → 교체 불가 (사용 중)
```

```cpp
// 의사 코드
buffer_block* pin_block(block_id) {
    block = find_in_buffer(block_id);
    if (block == null) {
        block = read_from_disk(block_id);
        add_to_buffer(block);
    }
    block->pin_count++;
    return block;
}

void unpin_block(buffer_block* block) {
    block->pin_count--;
}
```

### 5.3 락킹 (Locking)

**목적:**
- 동시성 제어
- 여러 트랜잭션이 동시에 같은 블록에 접근할 때 일관성 보장

**락 타입:**

1. **공유 락 (Shared Lock, S-Lock)**
   - 읽기 작업용
   - 여러 트랜잭션이 동시에 획득 가능

2. **배타 락 (Exclusive Lock, X-Lock)**
   - 쓰기 작업용
   - 한 트랜잭션만 획득 가능

**락 호환성 행렬:**

|       | S-Lock | X-Lock |
|-------|--------|--------|
| S-Lock|   ✓    |   ✗    |
| X-Lock|   ✗    |   ✗    |

### 5.4 버퍼 교체 정책 (Buffer Replacement Policies)

#### 5.4.1 LRU (Least Recently Used)

**개념:**
- 가장 오래 사용되지 않은 블록을 교체

**구현:**
- 접근 시간 스탬프 또는 연결 리스트 사용

```
시간 순서: [최근] → [오래됨]
[Block A] → [Block B] → [Block C] → [Block D]
                                      ↑
                                   교체 대상
```

**장점:**
- 시간적 지역성(temporal locality)에 효과적
- 구현이 비교적 간단

**단점:**
- 순차 스캔에 취약 (큰 테이블 스캔 시 버퍼 오염)
- 오버헤드 존재 (접근 시간 기록)

#### 5.4.2 Clock (Second Chance)

**개념:**
- LRU의 근사 알고리즘
- 참조 비트(reference bit)와 순환 포인터 사용

**작동 방식:**
1. 각 블록에 참조 비트 할당
2. 블록 접근 시 참조 비트를 1로 설정
3. 교체 시 포인터를 순회하며:
   - 참조 비트 = 1: 0으로 변경하고 넘어감
   - 참조 비트 = 0: 해당 블록 교체

```
┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
│ ref=1│ →  │ ref=0│ →  │ ref=1│ →  │ ref=1│ →
│Block1│    │Block2│    │Block3│    │Block4│
└──────┘    └──────┘    └──────┘    └──────┘
              ↑
          clock pointer
          (교체 대상)
```

**장점:**
- LRU보다 오버헤드가 적음
- 합리적인 근사치 제공

#### 5.4.3 MRU (Most Recently Used)

**개념:**
- 가장 최근에 사용된 블록을 교체
- LRU와 정반대

**사용 사례:**
- 반복적인 순차 스캔
- 인덱스 탐색 (root-to-leaf path)

**예시: 조인 연산**
```sql
-- Nested Loop Join
FOR each r IN R:
    FOR each s IN S:
        if r.key = s.key:
            output(r, s)
```
- 내부 테이블 S는 반복 스캔됨
- MRU 사용 시 R의 현재 레코드만 버퍼에 유지
- S의 블록들은 재사용 가능

**장점:**
- 순차 스캔에 효과적
- 버퍼 오염 방지

**단점:**
- 랜덤 접근 패턴에는 비효율적

#### 5.4.4 Toss-Immediate

**개념:**
- 블록 사용 즉시 버퍼에서 제거
- 재사용 가능성이 없는 경우 사용

**사용 사례:**
- 대용량 테이블의 일회성 스캔
- 백업 작업
- 데이터 마이그레이션

---

## 6. 열 지향 저장소 (Column-Oriented Storage)

### 6.1 행 지향 vs 열 지향

**행 지향 저장 (Row-Oriented Storage):**
```
Row 1: [ID=1][Name="Alice"][Age=25][City="Seoul"]
Row 2: [ID=2][Name="Bob"][Age=30][City="Busan"]
Row 3: [ID=3][Name="Carol"][Age=28][City="Incheon"]
```

**열 지향 저장 (Column-Oriented Storage):**
```
Column ID:   [1, 2, 3]
Column Name: ["Alice", "Bob", "Carol"]
Column Age:  [25, 30, 28]
Column City: ["Seoul", "Busan", "Incheon"]
```

### 6.2 열 지향 저장의 장점

1. **압축 효율**
   - 같은 타입의 데이터가 연속적으로 저장되어 압축률 향상
   - Run-Length Encoding (RLE), Dictionary Encoding 등 적용 가능

2. **I/O 효율**
   - 필요한 컬럼만 읽으면 됨
   - 분석 쿼리에 매우 효과적

```sql
-- 분석 쿼리 예시
SELECT AVG(age) FROM users WHERE city = 'Seoul';
-- 행 지향: 모든 컬럼 읽음
-- 열 지향: age, city 컬럼만 읽음 (I/O 감소)
```

3. **벡터화 연산**
   - CPU의 SIMD (Single Instruction Multiple Data) 명령어 활용
   - 한 번에 여러 값 처리 가능

4. **집계 연산 최적화**
   - SUM, AVG, COUNT 등의 집계 함수에 유리

### 6.3 열 지향 저장의 단점

1. **레코드 재구성 비용**
   - 전체 행을 조회할 때 여러 컬럼을 조합해야 함
   - 튜플 재구성 오버헤드

2. **삽입/갱신 비용**
   - 여러 컬럼 파일에 분산 저장
   - 트랜잭션 처리가 복잡함

3. **작은 범위 쿼리에 비효율적**
   - 특정 레코드 하나만 조회 시 오히려 느림

### 6.4 열 지향 파일 포맷

#### 6.4.1 ORC (Optimized Row Columnar)

**특징:**
- Hadoop 생태계에서 개발
- 스트라이프(stripe) 단위로 데이터 그룹화
- 각 스트라이프 내에서 열 지향 저장

**구조:**
```
┌────────────────────────────────┐
│        File Footer             │  ← 메타데이터
├────────────────────────────────┤
│        Stripe 3                │
│  ┌──────────────────────────┐  │
│  │  Index Data              │  │
│  │  Row Data (Columnar)     │  │
│  │  Stripe Footer           │  │
│  └──────────────────────────┘  │
├────────────────────────────────┤
│        Stripe 2                │
├────────────────────────────────┤
│        Stripe 1                │
└────────────────────────────────┘
```

**장점:**
- 우수한 압축률
- 빠른 읽기 성능
- 스키마 진화(schema evolution) 지원

#### 6.4.2 Parquet

**특징:**
- Apache 프로젝트
- 중첩 구조(nested structure) 지원
- 다양한 인코딩 및 압축 방식 지원

**구조:**
```
┌────────────────────────────────┐
│        Magic Number            │
├────────────────────────────────┤
│        Row Group 1             │
│  ┌──────────────────────────┐  │
│  │  Column Chunk A          │  │
│  │  Column Chunk B          │  │
│  │  Column Chunk C          │  │
│  └──────────────────────────┘  │
├────────────────────────────────┤
│        Row Group 2             │
├────────────────────────────────┤
│        Footer                  │
│  - Schema                      │
│  - Column Metadata             │
│  - Row Group Metadata          │
└────────────────────────────────┘
```

**인코딩 방식:**
- Plain Encoding
- Dictionary Encoding
- Run Length Encoding (RLE)
- Delta Encoding

**압축 알고리즘:**
- Snappy (빠른 압축/해제)
- GZIP (높은 압축률)
- LZO, ZSTD 등

### 6.5 열 지향 저장소 사용 사례

**적합한 경우:**
- 분석/집계 쿼리 (OLAP)
- 데이터 웨어하우스
- 로그 분석
- 머신러닝 특성 추출

**부적합한 경우:**
- 트랜잭션 처리 (OLTP)
- 빈번한 레코드 단위 갱신
- 소량의 랜덤 읽기

---

## 7. 하이브리드 접근법

### 7.1 PAX (Partition Attributes Across)

**개념:**
- 페이지 단위로는 행 지향, 페이지 내부에서는 열 지향
- 양쪽의 장점을 결합

**구조:**
```
┌─────────────────────────────────┐
│          Page 1                 │
│  ┌───────────────────────────┐  │
│  │ All values of Column A    │  │
│  │ All values of Column B    │  │
│  │ All values of Column C    │  │
│  └───────────────────────────┘  │
├─────────────────────────────────┤
│          Page 2                 │
│  ┌───────────────────────────┐  │
│  │ All values of Column A    │  │
│  │ All values of Column B    │  │
│  │ All values of Column C    │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

**장점:**
- 캐시 효율 향상
- SIMD 명령어 활용 가능
- 튜플 재구성 비용 감소

### 7.2 Delta Store + Column Store

**개념:**
- 메인 스토어: 열 지향 (읽기 최적화)
- 델타 스토어: 행 지향 (쓰기 최적화)
- 주기적으로 델타 스토어를 메인 스토어에 병합

```
┌──────────────────────────────────┐
│        Delta Store (행 지향)      │  ← 최근 삽입/갱신
│  빠른 쓰기, 작은 크기             │
└──────────────────────────────────┘
               ↓ (주기적 병합)
┌──────────────────────────────────┐
│        Main Store (열 지향)       │  ← 대량 데이터
│  빠른 읽기, 높은 압축률            │
└──────────────────────────────────┘
```

**예시: SAP HANA, Vertica**

---

## 8. 성능 최적화 기법

### 8.1 프리페칭 (Prefetching)

**개념:**
- 필요할 것으로 예상되는 블록을 미리 읽어옴
- 디스크 대기 시간 숨김

**순차 프리페칭:**
- 순차 스캔 시 다음 블록들을 미리 읽어옴

### 8.2 비동기 I/O (Asynchronous I/O)

**개념:**
- I/O 요청 후 완료를 기다리지 않고 다른 작업 수행
- I/O 병렬화

### 8.3 압축 (Compression)

**장점:**
- 디스크 공간 절약
- I/O 량 감소 (네트워크 전송 시에도)

**단점:**
- CPU 오버헤드 (압축/해제)
- 랜덤 접근 어려움

**압축 기법:**
- Dictionary Encoding
- Run-Length Encoding (RLE)
- Bit-packing
- Delta Encoding
- Snappy, ZSTD, GZIP 등

---

## 정리

데이터베이스의 저장 구조는 성능과 효율성에 직접적인 영향을 미치는 핵심 요소입니다.

**핵심 포인트:**

1. **파일 조직**: 고정 길이 레코드의 단순함 vs 가변 길이 레코드의 유연성 (Slotted Page)
2. **레코드 배치**: Heap (빠른 삽입) vs Sequential (빠른 검색) vs Multitable Clustering (빠른 조인)
3. **버퍼 관리**: LRU (일반적), MRU (순차 스캔), Clock (효율적 근사)
4. **열 지향 저장소**: 분석 쿼리에 최적화, 압축 효율 우수, ORC/Parquet 포맷

**설계 고려사항:**

- **워크로드 특성**: OLTP vs OLAP
- **접근 패턴**: 랜덤 vs 순차
- **쿼리 유형**: 트랜잭션 vs 분석
- **데이터 특성**: 크기, 갱신 빈도, 스키마 복잡도

현대 데이터베이스는 이러한 다양한 저장 구조와 기법들을 상황에 맞게 조합하여 최적의 성능을 제공합니다.

---

## 참고 자료

- Database System Concepts (7th Edition) - Silberschatz, Korth, Sudarshan
- 데이터베이스시스템및응용 강의 자료
- [Apache Parquet Documentation](https://parquet.apache.org/)
- [ORC File Format Specification](https://orc.apache.org/)
